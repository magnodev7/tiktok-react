# src/driver.py - Vers√£o OTIMIZADA para VPS + TikTok + Chrome Local
import os
import time
import tempfile
import shutil
import uuid
from selenium import webdriver  # pyright: ignore[reportMissingImports]
from selenium.webdriver.chrome.options import Options  # pyright: ignore[reportMissingImports]
from selenium.webdriver.chrome.service import Service  # pyright: ignore[reportMissingImports]
from selenium.common.exceptions import ( # pyright: ignore[reportMissingImports]
    SessionNotCreatedException,
    WebDriverException,
    InvalidSessionIdException,
)  # pyright: ignore[reportMissingImports]
from webdriver_manager.chrome import ChromeDriverManager  # pyright: ignore[reportMissingImports]
from typing import Optional

def _is_remote() -> bool:
    return bool(os.getenv("SELENIUM_HUB_URL"))

def _hub_url() -> str:
    # Endpoint do Grid; sempre acrescente /wd/hub
    return os.getenv("SELENIUM_HUB_URL", "http://selenium:4444").rstrip("/") + "/wd/hub"

def _remote_options_full(user_data_dir: Optional[str] = None) -> Options:
    opts = Options()

    # Op√ß√µes essenciais para ambiente headless em container
    opts.add_argument("--no-sandbox")
    opts.add_argument("--disable-dev-shm-usage")  # Evita crashes em container
    opts.add_argument("--disable-gpu")
    opts.add_argument("--disable-extensions")
    opts.add_argument("--disable-infobars")
    opts.add_argument("--disable-notifications")
    opts.add_argument("--disable-popup-blocking")
    opts.add_argument("--disable-default-apps")
    opts.add_argument("--disable-features=VizDisplayCompositor")
    opts.add_argument("--disable-features=IsolateOrigins,site-per-process")

    # Anti-detec√ß√£o do TikTok
    opts.add_argument("--disable-blink-features=AutomationControlled")
    opts.add_experimental_option("excludeSwitches", ["enable-automation"])
    opts.add_experimental_option("useAutomationExtension", False)

    # Configura√ß√µes visuais e de navega√ß√£o
    opts.add_argument("--start-maximized")
    # opts.add_argument("--headless=new")  # Desativado: usar Xvfb em VPS para estabilidade
    opts.add_argument("--window-size=1920,1080")  # Tamanho consistente
    opts.add_argument("--lang=pt-BR")
    opts.add_argument("--no-first-run")
    opts.add_argument("--no-service-autorun")
    opts.add_argument("--password-store=basic")

    if user_data_dir:
        opts.add_argument(f"--user-data-dir={user_data_dir}")
    else:
        opts.add_argument("--user-data-dir=/tmp/chrome-user-data")

    # User-Agent realista para evitar detec√ß√£o
    opts.add_argument(
        "user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
    )

    # Prefer√™ncias do Chrome
    prefs = {
        "credentials_enable_service": False,
        "profile.password_manager_enabled": False,
        "profile.default_content_setting_values.notifications": 2,
        "profile.default_content_settings.popups": 0,
        "profile.managed_default_content_settings.images": 1,
        "profile.default_content_setting_values.media_stream": 1,
    }
    opts.add_experimental_option("prefs", prefs)

    return opts

REUSE_PROFILE = os.getenv("PERSIST_CHROME_PROFILE", "1").lower() in ("1", "true", "yes", "on")


def _resolve_profile_dir(profile_base_dir: Optional[str], remote: bool) -> str:
    """
    Gera um caminho √∫nico de profile por sess√£o para evitar bloqueios de user-data-dir.
    - Local: cria diret√≥rio real via mkdtemp (removido ao encerrar).
    - Remoto: apenas define caminho em /tmp (container remoto cria automaticamente).
    """
    suffix = uuid.uuid4().hex
    if remote:
        base = "/tmp"
        return f"{base.rstrip('/')}/chrome-user-data-{suffix}"

    base = profile_base_dir or tempfile.gettempdir()
    os.makedirs(base, exist_ok=True)
    if REUSE_PROFILE and profile_base_dir:
        persistent_dir = os.path.join(base, "chrome-profile")
        os.makedirs(persistent_dir, exist_ok=True)
        return persistent_dir
    return tempfile.mkdtemp(prefix="chrome-user-data-", dir=base)


def build_driver(profile_base_dir: Optional[str] = None):
    """Constr√≥i e retorna uma inst√¢ncia do WebDriver.
    Em modo remoto, conecta-se ao Selenium Grid.
    Em modo local, usa o ChromeDriver local.
    """
    remote = _is_remote()
    profile_dir = _resolve_profile_dir(profile_base_dir, remote)

    if remote:
        hub = _hub_url()
        opts = _remote_options_full(profile_dir)

        max_retries = 3
        for attempt in range(1, max_retries + 1):
            try:
                driver = webdriver.Remote(
                    command_executor=hub,
                    options=opts,
                )

                # Scripts anti-detec√ß√£o executados IMEDIATAMENTE ap√≥s criar o driver
                try:
                    driver.execute_script(
                        "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"
                    )
                    driver.execute_script("window.navigator.chrome = {runtime: {}}")
                    driver.execute_script("delete navigator.__proto__.webdriver")
                except Exception:
                    # Mesmo que falhe, segue
                    pass

                # Espera curta para estabilizar
                time.sleep(2)

                setattr(driver, "_profile_dir", profile_dir)
                return driver

            except (SessionNotCreatedException, WebDriverException) as e:
                print(f"‚ö†Ô∏è Tentativa {attempt} falhou: {str(e)}")
                if attempt < max_retries:
                    time.sleep(3)
                else:
                    raise Exception(
                        f"Falha ao criar sess√£o remota ap√≥s {max_retries} tentativas: {str(e)}"
                    ) from e
    else:
        # Modo local: usa Chrome instalado no sistema com webdriver-manager
        print("üîß Usando Chrome local com webdriver-manager...")
        driver_path = os.getenv("CHROMEDRIVER_PATH")
        if not driver_path:
            driver_path = shutil.which("chromedriver")

        if driver_path:
            service = Service(driver_path)
        else:
            service = Service(ChromeDriverManager().install())

        opts = _remote_options_full(profile_dir)

        chrome_binary = (
            os.getenv("CHROME_BINARY")
            or shutil.which("google-chrome")
            or shutil.which("google-chrome-stable")
            or shutil.which("chromium-browser")
            or shutil.which("chromium")
        )
        if chrome_binary:
            opts.binary_location = chrome_binary
        else:
            pass

        driver = webdriver.Chrome(service=service, options=opts)

        # Scripts anti-detec√ß√£o
        try:
            driver.execute_script(
                "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"
            )
            driver.execute_script("window.navigator.chrome = {runtime: {}}")
            driver.execute_script("delete navigator.__proto__.webdriver")
        except Exception:
            pass

        time.sleep(2)
        setattr(driver, "_profile_dir", profile_dir)
        return driver


def is_session_alive(driver: Optional[webdriver.Remote]) -> bool:
    """Valida se a sess√£o WebDriver ainda est√° viva."""
    if driver is None:
        return False
    try:
        _ = driver.session_id
        driver.execute_script("return 1")
        return True
    except (InvalidSessionIdException, WebDriverException):
        return False

def get_fresh_driver(existing: Optional[webdriver.Remote], profile_base_dir: Optional[str] = None) -> webdriver.Remote:
    """Reaproveita o driver se a sess√£o estiver viva; caso contr√°rio, recria."""
    if is_session_alive(existing):
        return existing
    old_profile = getattr(existing, "_profile_dir", None)
    try:
        if existing is not None:
            existing.quit()
    except Exception:
        pass
    if old_profile:
        basename = os.path.basename(old_profile.rstrip(os.sep))
        is_temp_profile = basename.startswith("chrome-user-data-")
        if not REUSE_PROFILE or is_temp_profile:
            try:
                shutil.rmtree(old_profile, ignore_errors=True)
            except Exception:
                pass
        else:
            # remove poss√≠veis locks deixados pelo Chrome
            for lock_name in ("SingletonLock", "SingletonCookie", "SingletonSocket"):
                lock_path = os.path.join(old_profile, lock_name)
                if os.path.exists(lock_path):
                    try:
                        os.remove(lock_path)
                    except Exception:
                        pass
    return build_driver(profile_base_dir=profile_base_dir)
